<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context: 3-1-dice-rolling-module
  Generated: 2025-11-09

  This file contains all relevant context for implementing Story 3-1.
  It is designed to be loaded into an LLM context window to provide
  comprehensive guidance for development without requiring additional
  file reads or searches.
-->

<story-context>
  <metadata>
    <story-id>3-1-dice-rolling-module</story-id>
    <story-name>Dice Rolling Module</story-name>
    <epic-id>3</epic-id>
    <epic-name>D&D 5e Mechanics Integration</epic-name>
    <status>drafted</status>
    <priority>Critical (P0)</priority>
    <estimated-effort>Small (2-4 hours)</estimated-effort>
    <implementation-file>src/mechanics/dice-roller.js</implementation-file>
    <test-file>tests/mechanics/dice-roller.test.js</test-file>
    <context-generated>2025-11-09</context-generated>
  </metadata>

  <!-- ================================================================ -->
  <!-- STORY OVERVIEW -->
  <!-- ================================================================ -->

  <story-overview>
    <statement>
      As a **player**, I want **a dice rolling system that accurately simulates D&D 5e dice mechanics**,
      so that **all ability checks, attacks, damage rolls, and saving throws use fair, random dice rolls
      with proper notation support**.
    </statement>

    <purpose>
      This is the foundational module for Epic 3 (D&D 5e Mechanics Integration). All subsequent stories
      in Epic 3 depend on this dice roller for generating random outcomes. This module must be:
      - **Accurate**: Follow D&D 5e dice notation exactly
      - **Secure**: Use cryptographically secure randomness (crypto.randomInt)
      - **Performant**: Complete rolls in &lt;10ms
      - **Reliable**: Never throw exceptions, always return result objects
      - **Transparent**: Provide detailed breakdown strings for player visibility
    </purpose>

    <scope>
      <in-scope>
        - Parse standard D&D dice notation (1d20, 2d6+3, 3d8-2)
        - Roll dice using crypto.randomInt() for secure randomness
        - Support advantage (roll 2d20, take higher)
        - Support disadvantage (roll 2d20, take lower)
        - Generate human-readable breakdown strings
        - Validate notation with limits (max 20 dice, max d100, max ±999 modifier)
        - Return result objects: {success, data, error}
      </in-scope>

      <out-of-scope>
        - Exploding dice (not in D&amp;D 5e core)
        - Drop lowest/highest (not needed for MVP)
        - Fudge dice or other non-D&amp;D systems
        - Dice history tracking (future story)
        - UI/visualization (command layer handles this)
      </out-of-scope>
    </scope>

    <dependencies>
      <blocking>None - First story in Epic 3</blocking>
      <enables>
        <story id="3-3">Ability Checks Handler</story>
        <story id="3-5">Combat Manager</story>
        <story id="3-7">Spellcasting Module</story>
        <story id="3-10">Mechanics Slash Commands</story>
      </enables>
    </dependencies>
  </story-overview>

  <!-- ================================================================ -->
  <!-- ACCEPTANCE CRITERIA -->
  <!-- ================================================================ -->

  <acceptance-criteria>
    <criterion id="AC-1" priority="P0">
      <title>DiceRoller Module Creation</title>
      <given>The need for D&amp;D 5e dice rolling mechanics</given>
      <when>Story 3.1 is implemented</when>
      <then>
        - File `src/mechanics/dice-roller.js` must be created
        - Must export `DiceRoller` class
        - Must use dependency injection pattern (constructor accepts dependencies)
        - All methods must return `{success, data, error}` result objects (never throw exceptions)
      </then>
      <verification>Unit test verifying class exports and result object pattern</verification>
    </criterion>

    <criterion id="AC-2" priority="P0">
      <title>Standard Dice Notation Parsing</title>
      <given>D&amp;D 5e uses dice notation like "2d6+3", "1d20", "3d8-2"</given>
      <when>DiceRoller.roll(notation) is called</when>
      <then>
        - Must parse notation into components: count, sides, modifier
        - Must validate notation format using regex: `/^(\d{1,2})d(\d{1,3})([+-]\d{1,3})?$/i`
        - Must reject invalid notation (e.g., "d20", "2d", "abc")
        - Must return validation error for invalid input: `{success: false, error: "Invalid dice notation"}`
        - Must limit max values: count ≤ 20, sides ≤ 100, modifier ≤ ±999
      </then>
      <verification>Unit tests with valid and invalid notation strings</verification>
      <examples>
        <valid>
          <case input="1d20" output="{count: 1, sides: 20, modifier: 0}"/>
          <case input="2d6+3" output="{count: 2, sides: 6, modifier: 3}"/>
          <case input="3d8-2" output="{count: 3, sides: 8, modifier: -2}"/>
          <case input="4d10" output="{count: 4, sides: 10, modifier: 0}"/>
        </valid>
        <invalid>
          <case input="d20" reason="missing count"/>
          <case input="2d" reason="missing sides"/>
          <case input="abc" reason="not dice notation"/>
          <case input="99d999" reason="exceeds limits"/>
        </invalid>
      </examples>
    </criterion>

    <criterion id="AC-3" priority="P0">
      <title>Random Dice Rolling</title>
      <given>Parsed dice notation (e.g., count=2, sides=6, modifier=3)</given>
      <when>Dice are rolled</when>
      <then>
        - Must use `crypto.randomInt(1, sides + 1)` for each die (cryptographically secure random)
        - Must roll `count` number of dice
        - Must return array of individual roll results
        - Must calculate total: sum(rolls) + modifier
        - Must generate breakdown string for display
      </then>
      <verification>Unit test with 1000+ rolls, verify distribution and randomness</verification>
      <example>
        <input>roll("2d6+3")</input>
        <output>
{
  success: true,
  data: {
    notation: "2d6+3",
    rolls: [4, 6],
    modifier: 3,
    total: 13,
    breakdown: "2d6(4+6) + 3 = 13"
  }
}
        </output>
      </example>
    </criterion>

    <criterion id="AC-4" priority="P0">
      <title>Advantage Mechanic (Roll Twice, Take Higher)</title>
      <given>D&amp;D 5e advantage mechanic (roll 2d20, take higher result)</given>
      <when>DiceRoller.roll("1d20", {advantage: true}) is called</when>
      <then>
        - Must roll two d20s
        - Must return the higher of the two rolls as the result
        - Must include the discarded roll in the breakdown
        - Must only apply to d20 rolls (error if used with other dice)
      </then>
      <verification>Unit test verifying advantage logic</verification>
      <example>
        <input>roll("1d20", {advantage: true})</input>
        <rolls>14, 8</rolls>
        <output>
{
  success: true,
  data: {
    notation: "1d20",
    rolls: [14],
    discarded: [8],
    modifier: 0,
    total: 14,
    breakdown: "1d20(14, 8 discarded) = 14 [ADVANTAGE]",
    advantage: true
  }
}
        </output>
      </example>
    </criterion>

    <criterion id="AC-5" priority="P0">
      <title>Disadvantage Mechanic (Roll Twice, Take Lower)</title>
      <given>D&amp;D 5e disadvantage mechanic (roll 2d20, take lower result)</given>
      <when>DiceRoller.roll("1d20", {disadvantage: true}) is called</when>
      <then>
        - Must roll two d20s
        - Must return the lower of the two rolls as the result
        - Must include the discarded roll in the breakdown
        - Must only apply to d20 rolls (error if used with other dice)
      </then>
      <verification>Unit test verifying disadvantage logic</verification>
      <example>
        <input>roll("1d20", {disadvantage: true})</input>
        <rolls>14, 8</rolls>
        <output>
{
  success: true,
  data: {
    notation: "1d20",
    rolls: [8],
    discarded: [14],
    modifier: 0,
    total: 8,
    breakdown: "1d20(8, 14 discarded) = 8 [DISADVANTAGE]",
    disadvantage: true
  }
}
        </output>
      </example>
    </criterion>

    <criterion id="AC-6" priority="P0">
      <title>Performance Target</title>
      <given>Dice rolling is a frequently-called operation</given>
      <when>DiceRoller.roll() is executed</when>
      <then>
        - Operation must complete in &lt;10ms per roll
        - No noticeable lag for users
      </then>
      <verification>Performance benchmark test (100 consecutive rolls, measure avg time)</verification>
    </criterion>

    <criterion id="AC-7" priority="P0">
      <title>Result Object Format</title>
      <given>All Epic 3 modules use consistent result object pattern</given>
      <when>Any DiceRoller method is called</when>
      <then>
        - Must return `{success, data, error}` format
        - `success: true` → `data` contains roll result, `error: null`
        - `success: false` → `data: null`, `error` contains error message string
        - Never throw exceptions (all errors returned gracefully)
      </then>
      <verification>Unit tests verifying result object structure</verification>
    </criterion>
  </acceptance-criteria>

  <!-- ================================================================ -->
  <!-- ARCHITECTURAL CONTEXT -->
  <!-- ================================================================ -->

  <architectural-context>
    <patterns>
      <pattern name="Result Object Pattern">
        <description>
          All async operations in Kapi-s-RPG return result objects instead of throwing exceptions.
          This provides consistent error handling and makes success/failure explicit.
        </description>
        <format>
{
  success: boolean,
  data: object | null,
  error: string | null
}
        </format>
        <usage>
          - success=true: data contains the result, error is null
          - success=false: data is null, error contains error message
          - Never throw exceptions from public methods
          - Use try/catch internally, return error result objects on catch
        </usage>
        <example-from-codebase>
// From StateManager (src/core/state-manager.js)
async loadState(locationId) {
  try {
    // ... load and parse state
    return {
      success: true,
      data: stateData,
      error: null
    };
  } catch (error) {
    return {
      success: false,
      data: null,
      error: `Failed to load state: ${error.message}`
    };
  }
}
        </example-from-codebase>
      </pattern>

      <pattern name="Dependency Injection">
        <description>
          All classes accept dependencies via constructor to enable testing with mocks.
          Default to real implementations but allow override.
        </description>
        <usage>
          - Constructor accepts deps object with optional properties
          - Destructure deps with defaults: `const {fs = require('fs').promises} = deps`
          - Store dependencies as instance properties
          - Use injected dependencies throughout class methods
        </usage>
        <example-from-codebase>
// From StateManager (src/core/state-manager.js)
class StateManager {
  constructor(deps = {}) {
    this.fs = deps.fs || fs;
    this.path = deps.path || path;
    this.yaml = deps.yaml || yaml;
    this.locationsDir = deps.locationsDir || 'game-data/locations';
  }

  // Use this.fs, this.path, etc. in methods
}
        </example-from-codebase>
      </pattern>

      <pattern name="File-First Architecture">
        <description>
          Kapi-s-RPG stores all game state in human-readable files (Markdown/YAML).
          The DiceRoller is stateless and doesn't persist data, but future modules
          will save dice roll history to log files.
        </description>
        <relevance>
          DiceRoller doesn't interact with file system directly, but it must:
          - Return transparent results (breakdown strings)
          - Enable external logging by providing complete roll data
          - Support replay by accepting injected random function
        </relevance>
      </pattern>

      <pattern name="No External Dependencies for Core Logic">
        <description>
          Kapi-s-RPG minimizes npm dependencies. Use Node.js built-in modules when possible.
          Custom implementation preferred over external packages unless complex.
        </description>
        <decision-context>
          - Decision made: Custom dice roller implementation (see docs/dice-rolling-decision.md)
          - Rationale: Zero dependencies, D&amp;D 5e-specific, secure randomness
          - Use crypto.randomInt() from Node.js crypto module (built-in)
          - No need for dice-roller or d20 npm packages
        </decision-context>
      </pattern>
    </patterns>

    <code-style>
      <conventions>
        - JSDoc comments for all public methods
        - Private methods prefixed with underscore (_rollDie)
        - Use async/await for consistency (even if not truly async)
        - Descriptive variable names (notation, rollResults, not n, r)
        - ES6+ syntax (const/let, arrow functions, destructuring)
        - CommonJS modules (module.exports, require) for Node.js
      </conventions>

      <testing-conventions>
        - Jest testing framework
        - Test files in tests/mechanics/ directory
        - Mock dependencies in beforeEach
        - Restore mocks in afterEach
        - Descriptive test names: "should [expected behavior] when [condition]"
        - Group tests with describe blocks
        - Target ≥90% statement coverage
        - Include performance benchmarks
        - Include statistical distribution tests for randomness
      </testing-conventions>
    </code-style>

    <integration-points>
      <upstream>None (first Epic 3 module)</upstream>

      <downstream>
        <module name="AbilityCheckHandler" story="3-3">
          Will call DiceRoller.roll("1d20", {advantage/disadvantage}) for ability checks
        </module>
        <module name="CombatManager" story="3-5">
          Will call DiceRoller.roll() for attack rolls and damage
        </module>
        <module name="SpellManager" story="3-7">
          Will call DiceRoller.roll() for spell damage/healing
        </module>
        <module name="MechanicsCommandHandler" story="3-10">
          Will expose DiceRoller via /roll command for manual dice rolls
        </module>
      </downstream>
    </integration-points>

    <performance-requirements>
      <requirement>
        <metric>Roll Execution Time</metric>
        <target>&lt;10ms per roll</target>
        <rationale>Frequently called operation, must not introduce lag</rationale>
        <measurement>Benchmark test: 100 consecutive rolls, calculate average</measurement>
      </requirement>

      <requirement>
        <metric>Memory Usage</metric>
        <target>Minimal (stateless, no caching)</target>
        <rationale>DiceRoller instances should be lightweight</rationale>
      </requirement>
    </performance-requirements>
  </architectural-context>

  <!-- ================================================================ -->
  <!-- TECHNICAL IMPLEMENTATION GUIDANCE -->
  <!-- ================================================================ -->

  <implementation-guidance>
    <class-structure>
      <file-path>src/mechanics/dice-roller.js</file-path>

      <class-definition>
/**
 * DiceRoller - Custom dice rolling implementation for D&amp;D 5e
 *
 * Features:
 * - Parse standard D&amp;D dice notation (1d20, 2d6+3, etc.)
 * - Support advantage/disadvantage for d20 rolls
 * - Cryptographically secure randomness via crypto.randomInt()
 * - Detailed breakdown strings for transparency
 * - Result object pattern (no exceptions)
 * - Dependency injection for testability
 *
 * @module src/mechanics/dice-roller
 */

const crypto = require('crypto');

class DiceRoller {
  /**
   * Creates a new DiceRoller instance
   *
   * @param {Object} deps - Dependencies (for testing)
   * @param {Function} deps.randomInt - Random number generator (default: crypto.randomInt)
   */
  constructor(deps = {}) {
    this.randomInt = deps.randomInt || crypto.randomInt;
  }

  /**
   * Roll dice from notation string
   *
   * @param {string} notation - Dice notation (e.g., "2d6+3", "1d20")
   * @param {Object} options - Roll options
   * @param {boolean} options.advantage - Roll 2d20, take higher (d20 only)
   * @param {boolean} options.disadvantage - Roll 2d20, take lower (d20 only)
   * @returns {Promise&lt;ResultObject&gt;} Roll result
   *
   * @example
   * const roller = new DiceRoller();
   * const result = await roller.roll("2d6+3");
   * // {success: true, data: {notation: "2d6+3", rolls: [4, 6], modifier: 3, total: 13, breakdown: "2d6(4+6) + 3 = 13"}}
   */
  async roll(notation, options = {}) {
    // TODO: Implementation
    // 1. Validate and parse notation
    // 2. Check for advantage/disadvantage
    // 3. Roll dice
    // 4. Calculate total
    // 5. Generate breakdown
    // 6. Return result object
  }

  /**
   * Validate dice notation format
   *
   * @param {string} notation - Notation to validate
   * @returns {boolean} True if valid, false otherwise
   *
   * @example
   * roller.validateNotation("2d6+3"); // true
   * roller.validateNotation("d20");   // false (missing count)
   */
  validateNotation(notation) {
    // TODO: Implementation
    // Regex: /^(\d{1,2})d(\d{1,3})([+-]\d{1,3})?$/i
    // Check limits: count ≤ 20, sides ≤ 100, modifier ≤ ±999
  }

  /**
   * Parse dice notation into components
   *
   * @private
   * @param {string} notation - Notation to parse
   * @returns {Object} {count, sides, modifier} or null if invalid
   */
  _parseNotation(notation) {
    // TODO: Implementation
    // Return {count: number, sides: number, modifier: number}
  }

  /**
   * Roll a single die
   *
   * @private
   * @param {number} sides - Number of sides (4, 6, 8, 10, 12, 20, 100)
   * @returns {number} Roll result (1 to sides)
   */
  _rollDie(sides) {
    return this.randomInt(1, sides + 1);
  }

  /**
   * Handle advantage/disadvantage for d20
   *
   * @private
   * @param {boolean} advantage - Roll with advantage
   * @param {boolean} disadvantage - Roll with disadvantage
   * @returns {Object} {roll, discarded} or {roll} if neither
   */
  _rollD20WithAdvantage(advantage, disadvantage) {
    // TODO: Implementation
    // If both advantage and disadvantage: normal roll (cancel out)
    // If advantage: roll twice, take max
    // If disadvantage: roll twice, take min
  }

  /**
   * Generate breakdown string for display
   *
   * @private
   * @param {Object} rollData - Roll data (count, sides, rolls, modifier, etc.)
   * @returns {string} Human-readable breakdown
   *
   * @example
   * // "2d6(4+6) + 3 = 13"
   * // "1d20(14, 8 discarded) = 14 [ADVANTAGE]"
   */
  _generateBreakdown(rollData) {
    // TODO: Implementation
  }
}

module.exports = DiceRoller;
      </class-definition>
    </class-structure>

    <implementation-steps>
      <step number="1">
        <title>Create module file and class skeleton</title>
        <tasks>
          - Create src/mechanics/dice-roller.js
          - Add JSDoc header comment
          - Import crypto module
          - Define DiceRoller class with constructor
          - Implement dependency injection for randomInt
          - Add module.exports
        </tasks>
      </step>

      <step number="2">
        <title>Implement notation validation</title>
        <tasks>
          - Create validateNotation() method
          - Define regex pattern: /^(\d{1,2})d(\d{1,3})([+-]\d{1,3})?$/i
          - Test regex match
          - Validate limits (count ≤ 20, sides ≤ 100, modifier ≤ ±999)
          - Return boolean
        </tasks>
      </step>

      <step number="3">
        <title>Implement notation parsing</title>
        <tasks>
          - Create _parseNotation() private method
          - Apply regex to extract count, sides, modifier
          - Parse strings to integers
          - Handle missing modifier (default to 0)
          - Return {count, sides, modifier} object
        </tasks>
      </step>

      <step number="4">
        <title>Implement basic dice rolling</title>
        <tasks>
          - Implement _rollDie(sides) using this.randomInt(1, sides + 1)
          - Create roll() method skeleton
          - Validate notation (return error if invalid)
          - Parse notation
          - Roll 'count' number of dice
          - Calculate total: sum(rolls) + modifier
          - Return result object
        </tasks>
      </step>

      <step number="5">
        <title>Implement advantage/disadvantage</title>
        <tasks>
          - Create _rollD20WithAdvantage() method
          - Check if notation is 1d20 (error if advantage used on non-d20)
          - Handle both advantage and disadvantage (cancel out)
          - Implement advantage: roll twice, take max
          - Implement disadvantage: roll twice, take min
          - Store discarded roll
          - Update roll() method to call this when options.advantage/disadvantage set
        </tasks>
      </step>

      <step number="6">
        <title>Implement breakdown generation</title>
        <tasks>
          - Create _generateBreakdown() method
          - Format rolls: "2d6(4+6)"
          - Format modifier: " + 3" or " - 2" (omit if 0)
          - Format total: " = 13"
          - Handle advantage/disadvantage: add [ADVANTAGE] or [DISADVANTAGE] tag
          - Include discarded rolls: "(14, 8 discarded)"
        </tasks>
      </step>

      <step number="7">
        <title>Add error handling</title>
        <tasks>
          - Wrap roll() method in try/catch
          - Return {success: false, data: null, error: message} on errors
          - Validate options (error if advantage used on non-d20)
          - Handle edge cases (empty notation, null, undefined)
          - Add input sanitization (trim whitespace, case insensitive)
        </tasks>
      </step>
    </implementation-steps>

    <edge-cases>
      <case>
        <scenario>Empty or null notation</scenario>
        <handling>Return {success: false, error: "Invalid dice notation"}</handling>
      </case>

      <case>
        <scenario>Notation with spaces ("  2d6+3  ")</scenario>
        <handling>Trim before parsing</handling>
      </case>

      <case>
        <scenario>Case insensitivity ("2D6", "2d6")</scenario>
        <handling>Use case-insensitive regex flag (/i)</handling>
      </case>

      <case>
        <scenario>Both advantage and disadvantage true</scenario>
        <handling>Cancel out, perform normal roll</handling>
      </case>

      <case>
        <scenario>Advantage on non-d20 (e.g., "2d6" with advantage)</scenario>
        <handling>Return error: "Advantage/disadvantage only applies to d20 rolls"</handling>
      </case>

      <case>
        <scenario>Zero modifier in notation</scenario>
        <handling>Don't display "+0" in breakdown (e.g., "2d6(4+6) = 10", not "2d6(4+6) + 0 = 10")</handling>
      </case>

      <case>
        <scenario>Negative total result</scenario>
        <handling>Allow negative results (e.g., 1d4-10 could be -9 to -6)</handling>
      </case>

      <case>
        <scenario>Notation exceeding limits (99d999)</scenario>
        <handling>Return error: "Invalid dice notation" (validation fails)</handling>
      </case>
    </edge-cases>

    <security-considerations>
      <consideration>
        <title>Use Cryptographically Secure Randomness</title>
        <rationale>
          Math.random() is not cryptographically secure and can be predicted.
          For "fair" dice rolls that players trust, use crypto.randomInt().
        </rationale>
        <implementation>
          const crypto = require('crypto');
          const result = crypto.randomInt(1, sides + 1); // 1 to sides (inclusive)
        </implementation>
      </consideration>

      <consideration>
        <title>Input Validation</title>
        <rationale>
          Prevent malicious input that could cause performance issues or crashes.
        </rationale>
        <implementation>
          - Limit dice count to 20
          - Limit sides to 100
          - Limit modifier to ±999
          - Validate notation format with regex
        </implementation>
      </consideration>
    </security-considerations>
  </implementation-guidance>

  <!-- ================================================================ -->
  <!-- TESTING STRATEGY -->
  <!-- ================================================================ -->

  <testing-strategy>
    <test-file>tests/mechanics/dice-roller.test.js</test-file>

    <coverage-target>≥95% statement coverage</coverage-target>

    <test-categories>
      <category name="Constructor and Initialization">
        <tests>
          - Should initialize with default dependencies
          - Should accept custom randomInt via dependency injection
          - Should use injected randomInt for dice rolls
        </tests>
      </category>

      <category name="Notation Validation">
        <tests>
          - Should validate correct notation: "1d20", "2d6+3", "3d8-2"
          - Should reject missing count: "d20"
          - Should reject missing sides: "2d"
          - Should reject non-numeric: "abc"
          - Should handle case insensitivity: "2D6" same as "2d6"
          - Should handle whitespace: "  2d6+3  " (trim)
          - Should reject exceeding limits: "99d999", "21d6", "1d101"
        </tests>
      </category>

      <category name="Basic Dice Rolling">
        <tests>
          - Should roll 1d20 and return result 1-20
          - Should roll 2d6+3 and return result 5-15
          - Should roll 3d8-2 and return result 1-22
          - Should handle negative results: 1d4-10 returns -9 to -6
          - Should return array of individual rolls
          - Should calculate correct total
          - Should generate breakdown string
        </tests>
      </category>

      <category name="Advantage">
        <tests>
          - Should roll 2d20 and take higher result
          - Should include discarded roll in data
          - Should include [ADVANTAGE] in breakdown
          - Should error if used on non-d20 rolls
        </tests>
      </category>

      <category name="Disadvantage">
        <tests>
          - Should roll 2d20 and take lower result
          - Should include discarded roll in data
          - Should include [DISADVANTAGE] in breakdown
          - Should error if used on non-d20 rolls
        </tests>
      </category>

      <category name="Advantage + Disadvantage">
        <tests>
          - Should cancel out and perform normal roll
          - Should roll only once
          - Should not include discarded roll
        </tests>
      </category>

      <category name="Result Object Format">
        <tests>
          - Success case should return {success: true, data: {...}, error: null}
          - Error case should return {success: false, data: null, error: "..."}
          - Should never throw exceptions
        </tests>
      </category>

      <category name="Randomness Distribution">
        <tests>
          - Should roll 1d20 1000 times
          - Each number 1-20 should appear ~50 times (±20)
          - Chi-squared test for uniform distribution
          - Should use crypto.randomInt (verify via dependency injection)
        </tests>
      </category>

      <category name="Performance">
        <tests>
          - Should roll 100 times consecutively
          - Average time per roll should be &lt;10ms
          - Measure with performance.now() or hrtime
        </tests>
      </category>
    </test-categories>

    <mock-strategy>
      <approach>
        Inject mock randomInt function for deterministic testing.
        Use real crypto.randomInt() for distribution and performance tests.
      </approach>

      <example>
const DiceRoller = require('../../src/mechanics/dice-roller');

describe('DiceRoller', () => {
  describe('roll() with mocked randomness', () => {
    it('should handle advantage on 1d20', async () => {
      // Mock randomInt to return predictable values
      const mockRandomInt = jest.fn()
        .mockReturnValueOnce(8)  // First roll
        .mockReturnValueOnce(14); // Second roll

      const roller = new DiceRoller({ randomInt: mockRandomInt });
      const result = await roller.roll('1d20', { advantage: true });

      expect(result.success).toBe(true);
      expect(result.data.total).toBe(14); // Higher of 8, 14
      expect(result.data.discarded).toEqual([8]);
      expect(result.data.advantage).toBe(true);
      expect(result.data.breakdown).toContain('[ADVANTAGE]');
    });
  });

  describe('roll() with real randomness', () => {
    it('should produce uniform distribution over 1000 rolls', async () => {
      const roller = new DiceRoller(); // Use real crypto.randomInt
      const rolls = [];

      for (let i = 0; i &lt; 1000; i++) {
        const result = await roller.roll('1d20');
        rolls.push(result.data.total);
      }

      // Each number 1-20 should appear ~50 times (±20)
      for (let num = 1; num &lt;= 20; num++) {
        const count = rolls.filter(r =&gt; r === num).length;
        expect(count).toBeGreaterThan(30); // At least 30
        expect(count).toBeLessThan(70);    // At most 70
      }
    });
  });
});
      </example>
    </mock-strategy>

    <performance-test-example>
describe('Performance', () => {
  it('should complete 100 rolls in &lt;1000ms (&lt;10ms avg)', async () => {
    const roller = new DiceRoller();
    const start = performance.now();

    for (let i = 0; i &lt; 100; i++) {
      await roller.roll('2d6+3');
    }

    const end = performance.now();
    const totalTime = end - start;
    const avgTime = totalTime / 100;

    expect(avgTime).toBeLessThan(10); // &lt;10ms per roll
  });
});
    </performance-test-example>
  </testing-strategy>

  <!-- ================================================================ -->
  <!-- DEFINITION OF DONE -->
  <!-- ================================================================ -->

  <definition-of-done>
    <checklist>
      <item priority="P0">src/mechanics/dice-roller.js created with DiceRoller class</item>
      <item priority="P0">All 7 acceptance criteria verified passing</item>
      <item priority="P0">Unit tests written with ≥95% code coverage</item>
      <item priority="P0">Distribution test (1000 rolls) passes chi-squared test</item>
      <item priority="P0">Performance test passes (&lt;10ms avg per roll)</item>
      <item priority="P0">All tests passing in CI (npm test)</item>
      <item priority="P0">Code reviewed (follows Epic 3 patterns)</item>
      <item priority="P0">JSDoc comments for all public methods</item>
      <item priority="P0">No linting errors (if linter configured)</item>
      <item priority="P0">Integration test: Import and use in simple test script</item>
      <item priority="P0">sprint-status.yaml updated: 3-1-dice-rolling-module: done</item>
      <item priority="P0">Story file updated to "done" status</item>
    </checklist>
  </definition-of-done>

  <!-- ================================================================ -->
  <!-- REFERENCE DOCUMENTATION -->
  <!-- ================================================================ -->

  <reference-documentation>
    <document>
      <title>Epic 3 Technical Specification</title>
      <location>docs/tech-spec-epic-3.md</location>
      <relevance>
        Defines DiceRoller as one of 15 core modules in Epic 3.
        Specifies integration with CharacterManager, CombatManager, SpellManager.
        AC-1 in tech spec: "Dice rolling supports all standard D&amp;D notation (1d20, 2d6+3, advantage/disadvantage, modifiers)"
      </relevance>
      <excerpt>
AC-1: Dice Rolling Engine
- Parse dice notation (1d20, 2d6+3, advantage/disadvantage)
- Support all D&amp;D dice types (d4, d6, d8, d10, d12, d20, d100)
- Result tracking and validation
- Integration with character modifiers

Module: DiceRoller
File: src/mechanics/dice-roller.js
Methods:
  - roll(notation, options): Roll dice and return result
  - validateNotation(notation): Validate dice notation format
  - parseNotation(notation): Parse notation into components

Dependencies: Node.js crypto module (crypto.randomInt)
Performance Target: &lt;10ms per roll
      </excerpt>
    </document>

    <document>
      <title>Dice Rolling Library Decision</title>
      <location>docs/dice-rolling-decision.md</location>
      <relevance>
        Documents the decision to build a custom dice roller instead of using npm packages.
        Rationale: Zero dependencies, D&amp;D 5e-specific, secure randomness, full control.
      </relevance>
      <excerpt>
## Recommendation: Custom Implementation

Rationale:
1. Architectural Consistency - Zero-dependency philosophy
2. D&amp;D 5e-Specific Needs - Simple notation, advantage/disadvantage
3. Security - crypto.randomInt() for cryptographically secure randomness
4. Performance - Zero overhead, &lt;10ms target
5. Simplicity - ~100 lines of code, easy to maintain

Implementation: Story 3-1 (Dice Rolling Module)
Owner: Developer Agent
      </excerpt>
    </document>

    <document>
      <title>Game Design Document</title>
      <location>docs/GDD.md</location>
      <relevance>
        Defines Kapi-s-RPG as LLM-powered D&amp;D 5e platform.
        Specifies authentic D&amp;D 5e experience as core pillar.
        Dice rolling is foundational to gameplay loop.
      </relevance>
    </document>

    <document>
      <title>Technical Architecture Document</title>
      <location>docs/technical-architecture.md</location>
      <relevance>
        Defines architectural principles:
        - File-First Design
        - Separation of Concerns (rules engine separate from narrative)
        - Extensibility and modularity
        - Result Object Pattern
        - Dependency Injection
      </relevance>
    </document>

    <document>
      <title>Character Sheet Schema</title>
      <location>docs/character-sheet-schema.yaml</location>
      <relevance>
        Defines character data structure that future modules will use.
        DiceRoller will integrate with ability scores, proficiency bonus, etc.
      </relevance>
    </document>

    <document>
      <title>D&amp;D 5e SRD - Monsters</title>
      <location>data/srd/monsters.yaml</location>
      <relevance>
        Example of damage notation that DiceRoller must support.
        E.g., "2d4 + 2" for Wolf bite, "2d8 + 4" for Ogre greatclub.
      </relevance>
    </document>
  </reference-documentation>

  <!-- ================================================================ -->
  <!-- EXAMPLE CODE FROM EXISTING MODULES -->
  <!-- ================================================================ -->

  <example-code>
    <example>
      <title>StateManager - Result Object Pattern</title>
      <file>src/core/state-manager.js</file>
      <snippet>
// Example of Result Object Pattern from StateManager
async loadState(locationId) {
  try {
    // Validate locationId
    if (!this._isValidLocationId(locationId)) {
      return {
        success: false,
        data: null,
        error: `Invalid location ID: ${locationId}`
      };
    }

    // Construct path and read file
    const statePath = this.path.join(this.locationsDir, locationId, 'State.md');
    const fileContent = await this.fs.readFile(statePath, 'utf-8');

    // Parse YAML frontmatter
    const stateData = this._parseStateFrontmatter(fileContent);

    return {
      success: true,
      data: stateData,
      error: null
    };
  } catch (error) {
    return {
      success: false,
      data: null,
      error: `Failed to load state for ${locationId}: ${error.message}`
    };
  }
}
      </snippet>
      <lessons>
        - Wrap entire method in try/catch
        - Validate inputs early, return error if invalid
        - Return {success: true, data, error: null} on success
        - Return {success: false, data: null, error: message} on failure
        - Never throw exceptions from public methods
      </lessons>
    </example>

    <example>
      <title>CalendarManager - Dependency Injection</title>
      <file>src/calendar/calendar-manager.js</file>
      <snippet>
// Example of Dependency Injection from CalendarManager
const fs = require('fs').promises;
const path = require('path');
const yaml = require('js-yaml');

class CalendarManager {
  constructor(deps = {}) {
    this.fs = deps.fs || fs;
    this.path = deps.path || path;
    this.yaml = deps.yaml || yaml;
    this.calendarPath = deps.calendarPath || 'calendar.yaml';
  }

  async loadCalendar() {
    const content = await this.fs.readFile(this.calendarPath, 'utf-8');
    const data = this.yaml.load(content);
    return { success: true, data, error: null };
  }
}

module.exports = CalendarManager;
      </snippet>
      <lessons>
        - Constructor accepts optional deps object
        - Destructure or use || to provide defaults
        - Store dependencies as instance properties (this.fs, this.yaml)
        - Use instance properties throughout class methods
        - This enables mocking in tests
      </lessons>
    </example>

    <example>
      <title>CalendarManager Tests - Mock Dependencies</title>
      <file>tests/calendar/calendar-manager.test.js</file>
      <snippet>
const CalendarManager = require('../../src/calendar/calendar-manager');

describe('CalendarManager', () => {
  let calendarManager;
  let mockFs;
  let mockYaml;

  beforeEach(() => {
    // Create fresh mocks for each test
    mockFs = {
      readFile: jest.fn(),
      writeFile: jest.fn(),
      access: jest.fn()
    };

    mockYaml = {
      load: jest.fn(),
      dump: jest.fn()
    };
  });

  describe('loadCalendar()', () => {
    it('should load calendar from file', async () => {
      const mockData = { currentDate: '735-10-01', currentTime: '09:00' };
      mockFs.readFile.mockResolvedValue('currentDate: 735-10-01\ncurrentTime: 09:00');
      mockYaml.load.mockReturnValue(mockData);

      calendarManager = new CalendarManager({
        fs: mockFs,
        yaml: mockYaml,
        calendarPath: 'test-calendar.yaml'
      });

      const result = await calendarManager.loadCalendar();

      expect(result.success).toBe(true);
      expect(result.data).toEqual(mockData);
      expect(mockFs.readFile).toHaveBeenCalledWith('test-calendar.yaml', 'utf-8');
      expect(mockYaml.load).toHaveBeenCalled();
    });
  });
});
      </snippet>
      <lessons>
        - Create mock objects in beforeEach for isolation
        - Use jest.fn() for mock functions
        - Use mockResolvedValue for async mocks
        - Inject mocks via constructor
        - Verify mock calls with toHaveBeenCalledWith
      </lessons>
    </example>
  </example-code>

  <!-- ================================================================ -->
  <!-- FUTURE INTEGRATION NOTES -->
  <!-- ================================================================ -->

  <future-integration>
    <note>
      <title>Ability Check Handler Integration (Story 3-3)</title>
      <description>
        Story 3-3 will create AbilityCheckHandler that calls DiceRoller.roll("1d20", options)
        with advantage/disadvantage based on character conditions and situation modifiers.
      </description>
      <expected-usage>
const roller = new DiceRoller();
const result = await roller.roll("1d20", { advantage: hasAdvantage });
const total = result.data.total + abilityModifier + proficiencyBonus;
const success = total &gt;= DC;
      </expected-usage>
    </note>

    <note>
      <title>Combat Manager Integration (Story 3-5)</title>
      <description>
        Story 3-5 will create CombatManager that calls DiceRoller for:
        - Attack rolls: "1d20" + attack bonus
        - Damage rolls: weapon/spell damage notation (e.g., "2d6+3")
        - Critical hits: double damage dice (e.g., "4d6+3" instead of "2d6+3")
      </description>
    </note>

    <note>
      <title>Mechanics Commands Integration (Story 3-10)</title>
      <description>
        Story 3-10 will expose DiceRoller via /roll command for manual dice rolls.
        Players can type "/roll 2d6+3" and see breakdown in console.
      </description>
    </note>

    <note>
      <title>Future: Dice History Logging</title>
      <description>
        Future story may add dice roll history tracking to session logs.
        DiceRoller already provides complete roll data (notation, rolls, total, breakdown)
        for external logging systems to capture.
      </description>
    </note>
  </future-integration>
</story-context>
